Exploring Graph Theory with NetworkX: An In-Depth Guide | by Syed Hamed Raza | Level Up CodingOpen in appSign upSign inWriteSign upSign inExploring Graph Theory with NetworkX: An In-Depth GuideCreating and Analyzing Directed, Undirected, Weighted, and Acyclic Graphs, Calculating Shortest Paths, Centrality Measures, and Verifying ConnectivitySyed Hamed Raza·FollowPublished inLevel Up Coding·7 min read·Dec 3, 2023--ListenSharePhoto by Nastya Dulhiier on UnsplashGraph Theory is a fascinating branch of mathematics that deals with the study of graphs, which are mathematical structures used to model relationships between entities. These entities are represented as vertices (or nodes), and the relationships between them are represented as edges. Graphs have applications in various fields, including computer science, biology, social science, and transportation planning. In this article, we will delve into the world of Graph Theory, exploring its types and implementations using NetworkX, a powerful Python library for working with graphs.Understanding GraphsBefore diving into the types of graphs and their implementations in NetworkX, let’s grasp the fundamental concepts of graphs.Basic Definitions:Vertex (Node): A fundamental unit of a graph, representing an entity.Edge: A connection between two vertices, representing a relationship.Graph: A collection of vertices and edges.Types of GraphsGraphs can be categorized into various types based on different characteristics. The two main categories are:Directed Graphs (DiGraph): In a directed graph, edges have a direction. They go from one vertex to another, indicating a one-way relationship. It’s denoted as G = (V, E), where V is the set of vertices, and E is the set of directed edges.Undirected Graphs (Graph): In an undirected graph, edges do not have a direction. The relationship between vertices is mutual. If there is an edge from vertex A to vertex B, there is also an edge from B to A. It’s represented as G = (V, E), where V is the set of vertices, and E is the set of undirected edges.Weighted Graphs: In weighted graphs, each edge has an associated numerical value called weight. These weights can represent distances, costs, or any other relevant quantity.Cyclic Graphs: A graph that contains at least one cycle, which is a closed path that starts and ends at the same vertex.Acyclic Graphs (DAGs — Directed Acyclic Graphs): A graph that has no cycles. Directed acyclic graphs are particularly essential in various applications, such as scheduling and dependency resolution.Implementing Graphs in NetworkXNow that we have a foundational understanding of graphs let’s explore how to implement and work with them in Python using the NetworkX library.InstallationBefore proceeding, ensure you have NetworkX installed. You can install it usingpip install networkx1. Undirected GraphLet’s start by creating a simple undirected graphimport networkx as nximport matplotlib.pyplot as plt# Create an empty graphG = nx.Graph()# Define a list of nodesnodes = ['Hamed', 'Moon', 'Raza', 'Danish', 'Basit']# Add nodes one by one to the graphfor node in nodes:    G.add_node(node)# Define a list of edgesedges = [('Hamed', 'Moon'), ('Moon', 'Raza'), ("Basit", "Raza"), ("Moon", "Danish"), ('Raza', 'Danish'), ('Danish', 'Basit'), ('Basit', 'Hamed')]# Add edges one by one to the graphfor edge in edges:    G.add_edge(*edge)# Draw the graphpos = nx.spring_layout(G)nx.draw(G, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600)# Display the graphplt.show()we start with an empty graph (G = nx.Graph()) and then add nodes and edges one by one. Replace the names in the nodes list and the pairs in the edges list with the real entities and connections from your dataset.2. Directed Graphslet’s create a small directed graph using a hypothetical airline dataset where nodes represent airports and directed edges represent flights between airportsimport networkx as nximport matplotlib.pyplot as plt# Create an empty directed graphairline_graph = nx.DiGraph()# Define a list of airportsairports = ['JFK', 'LAX', 'ORD', 'DFW', 'ATL']# Add airports as nodes to the directed graphfor airport in airports:    airline_graph.add_node(airport)# Define a list of directed flightsflights = [    ('JFK', 'LAX'), ('LAX', 'ORD'), ('ORD', 'DFW'), ('DFW', 'ATL'), ('ATL', 'JFK'),    ('JFK', 'ORD'), ('ORD', 'ATL'), ('ATL', 'LAX'), ('LAX', 'DFW'), ('DFW', 'JFK')]# Add directed flights as edges to the graphfor flight in flights:    airline_graph.add_edge(*flight)# Draw the directed graphpos = nx.circular_layout(airline_graph)nx.draw(airline_graph, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600, arrowsize=20)# Display the directed graphplt.show()The nodes represent airports, and the directed edges represent flights between airports.3. Weighted GraphsTo create a weighted graph, you can associate weights with edgesimport networkx as nximport matplotlib.pyplot as plt# Create an empty weighted graphweighted_graph = nx.Graph()# Define a list of nodesnodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']# Add nodes to the weighted graphweighted_graph.add_nodes_from(nodes)# Define a list of weighted edgesweighted_edges = [    ('A', 'B', 3), ('A', 'C', 5), ('B', 'C', 1),    ('B', 'D', 7), ('C', 'D', 2), ('C', 'E', 4),    ('D', 'E', 6), ('D', 'F', 8), ('E', 'F', 9),    ('F', 'G', 10)]# Add weighted edges to the graphweighted_graph.add_weighted_edges_from(weighted_edges)# Draw the weighted graphpos = nx.spring_layout(weighted_graph)nx.draw(weighted_graph, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600, font_size=10)# Add edge labels with weightsedge_labels = {(edge[0], edge[1]): edge[2] for edge in weighted_edges}nx.draw_networkx_edge_labels(weighted_graph, pos, edge_labels=edge_labels)# Display the weighted graphplt.show()the weighted_edges list contains tuples representing edges along with their weights. The add_weighted_edges_from function is used to add these edges to the graph. The graph is then visualized, and edge labels with weights are added for clarity.4. Cyclic GraphYou can generate a cyclic graph in NetworkX using the cycle_graph function.import networkx as nximport matplotlib.pyplot as plt# Generate a Cyclic Graph with 7 nodescyclic_graph = nx.cycle_graph(7)# Draw the Cyclic Graphpos = nx.circular_layout(cyclic_graph)nx.draw(cyclic_graph, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600)# Display the Cyclic Graphplt.show()The cycle_graph function is used to generate a cyclic graph with 7 nodes5. Acyclic Graphs (DAGs)Creating a directed acyclic graph (DAG) involves ensuring that the graph has no cycles. NetworkX provides a is_directed_acyclic_graph function to check for acyclicitywe can generate a Directed Acyclic Graph (DAG) in NetworkX using various algorithms. Here’s an example using the networkx.generators moduleimport networkx as nximport matplotlib.pyplot as plt# Generate a Directed Acyclic Graph (DAG) using a random graph generatordag = nx.gn_graph(7)  # Generate a random DAG with 7 nodes using the G(n, m) model# Check if dagis a directed acyclic graphis_dag = nx.is_directed_acyclic_graph(dag)print(f"The directed graph is a DAG: {is_dag}")# Draw the DAGpos = nx.shell_layout(dag)nx.draw(dag, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600)# Display the DAGplt.show()## Output## The directed graph is a DAG: TrueI used the gn_graph function from the networkx.generators module to generate a Directed Acyclic Graph (DAG) with 7 nodes using the G(n, m) model. This function returns True if the graph is a DAG and False otherwise.If you want more control over the structure of the DAG, you can create it manuallyimport networkx as nximport matplotlib.pyplot as plt# Create a Directed Acyclic Graph (DAG) manuallydag = nx.DiGraph()# Define nodesnodes = ['A', 'B', 'C', 'D', 'E', 'F', 'G']# Add nodes to the DAGdag.add_nodes_from(nodes)# Define directed edges to create a DAGedges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('D', 'G'), ('E', 'G')]# Add directed edges to the DAGdag.add_edges_from(edges)# Check if dagis a directed acyclic graphis_dag = nx.is_directed_acyclic_graph(dag)print(f"The directed graph is a DAG: {is_dag}")# Draw the DAGpos = nx.shell_layout(dag)nx.draw(dag, pos, with_labels=True, node_color='lightblue', font_weight='bold', node_size=600)# Display the DAGplt.show()## Output# The directed graph is a DAG: TrueIn this manual example, I defined a DAG with nodes ‘A’ to ‘G’ and added directed edges to ensure it remains acyclicAdvanced Graph OperationsNetworkX provides a plethora of functions for advanced graph operations. Let’s explore a few of them:1. Shortest PathsFinding the shortest path between two nodes in a graph is a common operation. NetworkX offers the shortest_path function# Find the shortest path using Dijkstra's algorithm between "B" and "G"print(nx.dijkstra_path(weighted_graph, "B", "G"))# Calculate the length of the shortest path between "B" and "G"print(nx.shortest_path_length(weighted_graph, 'B', 'G'))# Calculate the length of the shortest path considering edge weights between "B" and "G"print(nx.shortest_path_length(weighted_graph, 'B', 'G', weight='Weight'))## Output## ['B', 'C', 'D', 'F', 'G']## 3## 32. Centrality MeasuresCentrality measures help identify the most important nodes in a graph. NetworkX provides functions for various centrality measures, such as degree centrality, betweenness centrality, and eigenvector centrality# Degree Centralitydegree_centrality = nx.degree_centrality(weighted_graph)print(f"Degree Centrality: {degree_centrality}")# Betweenness Centralitybetweenness_centrality = nx.betweenness_centrality(weighted_graph, weight='weight')print(f"Betweenness Centrality: {betweenness_centrality}")# Eigenvector Centralityeigenvector_centrality = nx.eigenvector_centrality(weighted_graph)print(f"Eigenvector Centrality: {eigenvector_centrality}")## output## Degree Centrality: {'A': 0.3333333333333333, 'B': 0.5, 'C': 0.6666666666666666, 'D': 0.6666666666666666, 'E': 0.5, 'F': 0.5, 'G': 0.16666666666666666}## Betweenness Centrality: {'A': 0.0, 'B': 0.3333333333333333, 'C': 0.5666666666666667, 'D': 0.4, 'E': 0.0, 'F': 0.3333333333333333, 'G': 0.0}## Eigenvector Centrality: {'A': 0.2766426410510452, 'B': 0.39566290609878674, 'C': 0.4923597538775433, 'D': 0.501074052420653, 'E': 0.40709235334437577, 'F': 0.3133278486537114, 'G': 0.09761073582721326}3. ConnectivityNetworkX provides functions to check the connectivity of a graph# Check if the graph G is connectedprint(nx.is_connected(weighted_graph))## output# TrueThese functions help you understand how the nodes are connected within the graph.ConclusionIn this article, we’ve covered the basics of graphs, types of graphs, and their implementation using NetworkX. We’ve also delved into advanced graph operations, showcasing how NetworkX facilitates tasks such as finding shortest paths, calculating centrality measures, and assessing graph connectivity.Data ScienceMachine LearningAIMathematicsPython----FollowWritten by Syed Hamed Raza276 Followers·Writer for Level Up CodingMaster's degree in Computer Applied Technology from Huazhong University, Wuhan, China. Expert in ML, DL, Computer Vision, NLP. Passionate mentor and innovator.FollowHelpStatusAboutCareersPressBlogPrivacyTermsText to speechTeams































